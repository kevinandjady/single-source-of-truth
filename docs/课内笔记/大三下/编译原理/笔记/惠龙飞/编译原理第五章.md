> 本文中内容整理西安交通大学软件学院[吴晓军](https://gr.xjtu.edu.cn/web/xiaojunw)老师的ppt中，仅供学习使用，请勿转载或他用
> 参考教材：《程序设计语言 编译原理》（第3版） 陈火旺等 国防工业出版社

# 编译原理第五章——自下而上分析

_______________________________

#### 班级：软件2205 &emsp; 姓名：惠龙飞 &emsp;

_______________________________

### 目录

* 一、复习：语法分析的两种方式
* 二、自下而上分析概述
  * 1.:tiger:核心思想：移进-规约
  * 2.:dog:规范规约
  * 3.:lion:规范规约的两个问题
* 三、算符优先分析
  * 1.:frog:概念辨析-算符文法、算符优先文法
  * 2.:octopus:概念辨析-算符优先分析法、直观算符优先分析法
  * 3.:dolphin:概念辨析-算符文法、算符优先文法
  * 4.:whale: 利用优先关系表用直观算符优先分析法分析算数表达式(**不考可以跳过**)
  * 5.:ox:构造FIRSTVT(P)和LASTVT(P)两个集合(**必考！！**)
  * 6.:honeybee:利用FIRSTVT(P)和LASTVT(P)两个集合构造优先关系表(**必考！！**)
  * 7.:rabbit2:素短语
  * 8.:ram:优先函数(**感觉不会考，至少掌握下概念吧**)
* 四、LR分析法
  * 1.:blowfish:LR分析法概述
  * 2.:maple_leaf:LR分析过程
  * 3.:shell:LR(0) (**基础必须掌握！！**)
  * 4.:musical_note:SLR (**复习一手FOLLOW集~！！**)
  * 5.:panda_face:规范规约：LR(k) (**最容易考的！！**)
  * 6.:cat:LALR
* 五、本章总结

_______________________________

## 一、复习：语法分析的两种方式

* 自上而下(Top-down)
  * 从文法的开始符号出发，反复使用各种产生式，寻找"匹配"的推导。
  * 推导：根据文法的产生式规则，把串中出现的产生式的左部符号替換成右部。
  * 从树的根开始，构造语法树。
  * 递归下降分析法、预测分析程序。
* 自下而上(Bottom-up)
  * 从输入串开始，逐步进行归约，直到文法的开始符号。
  * 归约：根据文法的产生式规则，把串中出现的产生式的右部替换成左部符号。
  * 从树叶节点开始，构造语法树。
  * 算符优先分析法、LR分析法。

_______________________________

## 二、自下而上分析法概述

### 1. :tiger:核心思想：移进-规约

* 1.基本思想：从输入串开始，逐步归约，直到文法的开始。其中归约即为根据文法的产生式规则，把串中出现式的右部替换成左部符号。从语法树上分析，就是从树叶节点开始，构造语法树。
* 2.归约：利用栈，输入终结符号移进栈，当栈顶形成P的候选式时，就归约为它的左部P符号。
* 3.自下而上分析法就是“移进-规约法”

例5.1 移进-规约示例

文法G2:
S->aAcBe
A->b
A->Ab
B->d
输入串: abbcde

最左归约：abbcde =>aAbcde =>aAcde =>aAcBe =>S
最右推导：S =>aAcBe =>aAcde =>aAbcde =>abbcde


<img src="https://telegraph-image-5ms.pages.dev/file/40d20fe2f8160945b60c1.png" alt="image-20220117083528884" style="display: block; margin-left: auto; margin-right: auto; zoom:67%;">


<img src="https://telegraph-image-5ms.pages.dev/file/b970a4e88eb09b9478d5d.png" alt="image-20220117083528884" style="display: block; margin-left: auto; margin-right: auto; zoom:45%;">

### 2. :dog:规范规约

* 基本概念：
* 短语：令G是一个文法，S是文法的开始符号，假定aβδ是文法G的一个句型，**如果有S=*>αAδ 且A=+>β，则β称是句型aβ8相对于非终结符A的短语。**
* 直接短语：令G是一个文法，S是文法的开始符号，假定αβδ是文法G的一个句型，如果有S=*>αAδ 且A=+>β，则β称是句型αβδ相对于非终结符A的短语。**如果有A=>β，则称β是句型αAδ相对于规则A→β的直接短语。**
* 句柄：**一个句型的最左直接短语。**
* **以上基本不用看，看下图（有点丑我服了）**

<img src="https://telegraph-image-5ms.pages.dev/file/f459f3cb79da86bfcf194.png" alt="image-20220117083528884" style="display: block; margin-left: auto; margin-right: auto; zoom:67%;">

* 红色圆圈圈起来对应的子树是直接短语，红色加蓝色对应的子树是短语，其余都重复了。
* 直接短语：i1，i2，i3.
* 短语：i1，i2，i3，i1 *i2，i1* i2 + i3.
* 句柄：i1
* 规律：
* 在一棵句型对应的语法树中，以某非终结符为根的两代以上的子树的所有末端节点从左到右排列就是相对于该非终结符的一个短语，**比如i1," * ",i2是以T为根的子树,这棵子树有四层，该子树的末端是i1*i2。**
* 如果子树只有两代，则该短语是直接短语，**比如以F为根i1为孩子的子树和以F为根i2为孩子的子树以及以F为根i3为孩子的子树。**
* 继续基本概念：
* 规范推导：即最右推导；
* 规范句型：由规范推导所得的句型称为规范句型；
* 规范归约：是关于句型a的一个最右推导的逆过程，也称最左归约。

### 3. :lion:规范规约的两个问题

* **如何在句型中找出句柄？**
* **当相同的右部有很多时，选哪一个捏？**
* 为了解决上面的两个问题，我们有两种思路：
* 1.不对规范文法进行操作，我们直接用**算符优先分析法**分析**算符优先文法**这种简单文法。
* 2.采取**LR分析法**。
* 下面两部分将依次介绍算符优先分析法和LR分析法。

_______________________________

## 三、直观算符优先分析法

### 1.:frog:概念辨析-算符文法、算符优先文法

* **算符文法**
* 设有一个文法G，若G中有形如U->Vw的产生式，即它的任意产生式的右部都不含两个相继的非终结符，则称G为算数文法，或称为OG文法。
* **重点：不允许有两个连续的非终结符。**

* **算符优先文法**
<img src="https://telegraph-image-5ms.pages.dev/file/95a2480c852127bd6f48e.png" alt="image-20220117083528884" style="display: block; margin-left: auto; margin-right: auto; zoom:67%;">

<center>图片来源于西安交通大学软件工程专业编译原理 吴晓军 2024春</center>
&nbsp;

* **符号解释**
* 形似><+的符号，**没有传递性，也没有反对称性！！！**
* 他们只是描述两个终结符的优先关系。
* 读作：a的优先级低于（高于）（等于）b。

### 2.:octopus:概念辨析-算符优先分析法、直观算符优先分析法

* **直观算符优先分析法：**
* 基于直觉的、手工进行分析的方法，通常用于简单的文法或教学目的。
* **算符优先分析法：**
* 是一种自动化的语法分析技术，通常用于编译器设计和实现中。
* 二者本质是一个东西，都是效仿四则运算的计算过程而构造的一种语法分析方法。算符优先分析法的关键是比较两个相继出现的终结符的优先级而决定应采取的动作。
* **优点：**简单有效，适合表达式的分析。
* **缺点：**只适合于**算符优先文法**，是一个不大的文法类。
* **算符优先分析过程是自下而上的归约过程，但未必是严格的最左归约。也就是说，算符优先分析法不是一种规范归约法。所谓【算符优先分析法】就是定义算符之间的某种优先关系，借助于这种关系寻找“可归约串”进行归约的一种方法。**
* 换言之，我们没有解决自下而上分析的两个问题，只是挑了一种容易分析的文法。
  
### 3.:dolphin: 概念辨析-算符文法、算符优先文法

* 概念层面：算符文法是一种**文法的类型**，而算符优先文法是一种**分析方法**。算符文法定义了文法的结构，以便可以使用算符优先分析法进行解析。
* 应用范围：算符文法专门针对文法的结构，确保文法适合进行算符优先分析。算符优先文法则更广泛地指代一种分析技术，它可以用来解析满足特定条件的文法。
* 目的：算符文法的目的是为了确保文法的结构允许使用算符优先分析法，而算符优先文法的目的是为了提供一个有效的解析策略，以便能够处理具有优先级规则的表达式。

### 4.:whale: 利用优先关系表用直观算符优先分析法分析算数表达式（这玩意不考时间紧可以跳过）

#### 记号使用说明

* #：语句括号（栈底和输入串w后）
* θ：运算符栈的栈顶符
* a：刚读入终结符号
* OPTR：运算符栈
* OPND：操作数栈

#### 分析算法步骤

* **下面的><=都是优先符号**
* 1. 下一个输入终结符号读至a中。
* 2. 若a为i，则a入栈OPND，然后转第一步。
* 3. 若0 > a，则调用关于日的处理程序（语义程序），处理子表达式：E(1)0E(2)（其中,E(1)、E(2)分别为操作数OPND栈的次栈顶和栈顶）；将上述子表达式的结果再填入OPND栈；然后重新进入第3步。
* 4. 若θ = a，则
     * 若0 = '('并且a = ')'，则逐出OPTR栈顶的‘(’并且放弃a中的‘)’，然后转第1步；
     * 若0=a=‘#'，则分析成功结束。
* 5. 若θ< a，则a入栈OPTR，然后转第1步。
* 6. 若0与a不存在优先关系，则判输入串错误，调出错处理。
* **是不是看不懂，巧了我也是，看例题吧**
  
#### 例题

对于文法G：E->E+E|E*E|E↑E|(E)|i
其终结符的优先关系见下表。 **但其实不用看，这里就是算数运算的符号优先级**
**PS：下面的><=都是优先符号**
|      | +    | *    | ↑    | i    | (    | )    | #    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| +    | >    | <    | <    | <    | <    | >    | >    |
| *    | >    | >    | <    | <    | <    | >    | >    |
| ↑    | >    | >    | <    | <    | <    | >    | >    |
| i    | >    | >    | >    |      |      | >    | >    |
| (    | <    | <    | <    | <    | <    | =    |      |
| )    | >    | >    | >    |      |      | >    | >    |
| #    | <    | <    | <    | <    | <    |      | =    |

<img src="https://telegraph-image-5ms.pages.dev/file/9860252003e67b913d5c1.png" alt="image-20220117083528884" style="display: block; margin-left: auto; margin-right: auto; zoom:42%;">
<img src="https://telegraph-image-5ms.pages.dev/file/de1fe6b66e4c6fb9f62fe.png" alt="image-20220117083528884" style="display: block; margin-left: auto; margin-right: auto; zoom:42%;">
<img src="https://telegraph-image-5ms.pages.dev/file/bbebcb0fc11bfd5bf6437.png" alt="image-20220117083528884" style="display: block; margin-left: auto; margin-right: auto; zoom:42%;">
<img src="https://telegraph-image-5ms.pages.dev/file/50dbdb8404d12d828ba1c.png" alt="image-20220117083528884" style="display: block; margin-left: auto; margin-right: auto; zoom:42%;">
<img src="https://telegraph-image-5ms.pages.dev/file/08c1d4a470dc6976315c8.png" alt="image-20220117083528884" style="display: block; margin-left: auto; margin-right: auto; zoom:42%;">
<img src="https://telegraph-image-5ms.pages.dev/file/7f8cd5a3ebe5858f666ac.png" alt="image-20220117083528884" style="display: block; margin-left: auto; margin-right: auto; zoom:42%;">
<img src="https://telegraph-image-5ms.pages.dev/file/7bb47386bbaf350417657.png" alt="image-20220117083528884" style="display: block; margin-left: auto; margin-right: auto; zoom:42%;">


### 5.:ox:构造FIRSTVT(P)和LASTVT(P)两个集合

**牢记：FIRSTVT和LASTVT的意义：首/尾终结符集**

**FIRSTVT构造方法：**

1. 若有产生式 P -> a ...或者P -> Q a ...，那么a属于FIRSTVT(P)。
2. 若a属于FIRSTVT(Q)，且有产生式P -> Q...，那么a属于FIRSTVT(P)。

#### 例 文法

E -> T | E + T
T -> F | T * F
F -> P | P ↑ F
P -> i | ( E )
构造FIRSTVT和LASTVT。

#### 解

* 首先利用FIRSTVT构造方法的1，从上往下，得到：
* FIRSTVT(E)={+}
* FIRSTVT(T)={*}
* FIRSTVT(F)={↑}
* FIRSTVT(P)={i , (}
* 然后利用FIRSTVT构造方法的2，**从下往上**，得到：
* FIRSTVT(E)={+ , * , ↑ , i , (}
* FIRSTVT(T)={* , ↑ , i , (}
* FIRSTVT(F)={↑ , i , (}
* FIRSTVT(P)={i , (}
* FIRSTVT与LASTVT构造方式完全对称，直接给出：
* LASTVT(E)={+ , * , ↑ , i , )}
* LASTVT(T)={* , ↑ , i , )}
* LASTVT(F)={↑ , i , )}
* LASTVT(P)={i , )}

### 6.:honeybee:利用FIRSTVT(P)和LASTVT(P)两个集合构造优先关系表

**优先关系表构造方法：**
**#和#一定相等，直接填入**

<img src="https://telegraph-image-5ms.pages.dev/file/c38adf678148d60abe02a.png" alt="image-20220117083528884" style="display: block; margin-left: auto; margin-right: auto; zoom:42%;">

#### 例 文法

E -> T | E + T
T -> F | T * F
F -> P | P ↑ F
P -> i | ( E )
构造其优先关系表。

#### 解

* 1.先找优先级相等的关系：#和#一定相等，直接填入，P -> ( E )，则( = )。

|      | +    | *    | ↑    | i    | (    | )    | #    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| +    |      |      |      |      |      |      |      |
| *    |      |      |      |      |      |      |      |
| ↑    |      |      |      |      |      |      |      |
| i    |      |      |      |      |      |      |      |
| (    |      |      |      |      |      | =    |      |
| )    |      |      |      |      |      |      |      |
| #    |      |      |      |      |      |      | =    |

* 2.然后从上往下分析，E -> E + T，其中E +符合第四条，那么LASTVT(E)的每个元素优先级>+。
* 这个怎么理解呢？首先我们知道，优先级表的第一列是前面那个非终结符，第一行是后面那个终结符；其次我们可以这样理解，非终结符优先规约，那么E的终结符的优先级更高；那到底选是E的LASTVT还是FIRSTVT呢，因为+在后面，肯定选LASTVT。

|      | +    | *    | ↑    | i    | (    | )    | #    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| +    | >    |      |      |      |      |      |      |
| *    | >    |      |      |      |      |      |      |
| ↑    | >    |      |      |      |      |      |      |
| i    | >    |      |      |      |      |      |      |
| (    |      |      |      |      |      | =    |      |
| )    | >    |      |      |      |      |      |      |
| #    |      |      |      |      |      |      | =    |

* 同理继续分析，这里我多写几个帮助理解，E -> E + T，其中+ T符合第三条，那么+的优先级小于FIRSTVT(T)。

|      | +    | *    | ↑    | i    | (    | )    | #    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| +    | >    | <    | <    | <    | <    |      |      |
| *    | >    |      |      |      |      |      |      |
| ↑    | >    |      |      |      |      |      |      |
| i    | >    |      |      |      |      |      |      |
| (    |      |      |      |      |      | =    |      |
| )    | >    |      |      |      |      |      |      |
| #    |      |      |      |      |      |      | =    |

* 同理继续分析，T ->T *F，其中T*符合第四条，那么LASTVT(T)的每个元素优先级> *。

|      | +    | *    | ↑    | i    | (    | )    | #    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| +    | >    | <    | <    | <    | <    |      |      |
| *    | >    | >    |      |      |      |      |      |
| ↑    | >    | >    |      |      |      |      |      |
| i    | >    | >    |      |      |      |      |      |
| (    |      |      |      |      |      | =    |      |
| )    | >    | >    |      |      |      |      |      |
| #    |      |      |      |      |      |      | =    |

* 同理继续分析，T ->T *F，其中* F符合第三条，那么*的优先级小于FIRSTVT(F)的每个元素。

|      | +    | *    | ↑    | i    | (    | )    | #    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| +    | >    | <    | <    | <    | <    |      |      |
| *    | >    | >    | <    | <    | <    |      |      |
| ↑    | >    | >    |      |      |      |      |      |
| i    | >    | >    |      |      |      |      |      |
| (    |      |      |      |      |      | =    |      |
| )    | >    | >    |      |      |      |      |      |
| #    |      |      |      |      |      |      | =    |

* 同理继续分析，给出差最后一步的答案：

|      | +    | *    | ↑    | i    | (    | )    | #    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| +    | >    | <    | <    | <    | <    | >    |      |
| *    | >    | >    | <    | <    | <    | >    |      |
| ↑    | >    | >    | <    | <    | <    | >    |      |
| i    | >    | >    | >    |      |      | >    |      |
| (    | <    | <    | <    | <    | <    | =    |      |
| )    | >    | >    | >    |      |      | >    |      |
| #    |      |      |      |      |      |      | =    |

* 好滴，千万不要忘记最后一步：S -> # E #，满足# E，那么#的优先级低于FIRSTVT(E)的每一个元素，满足E #，那么LASTVT(E)的每一个元素优先级都大于#。

|      | +    | *    | ↑    | i    | (    | )    | #    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| +    | >    | <    | <    | <    | <    | >    | >    |
| *    | >    | >    | <    | <    | <    | >    | >    |
| ↑    | >    | >    | <    | <    | <    | >    | >    |
| i    | >    | >    | >    |      |      | >    | >    |
| (    | <    | <    | <    | <    | <    | =    |      |
| )    | >    | >    | >    |      |      | >    | >    |
| #    | <    | <    | <    | <    | <    |      | =    |

**至此构造完成！**

### 7.:rabbit2:素短语

#### 素短语概念

* 所谓**素短语**是指这样一个短语，它至少含有一个终结符，并且除自身之外不再含任何更小的素短语。
* 句型最左边的那个素短语叫**最左素短语。**
* **注意：素短语和直接短语很类似，但没有啥关系。**
* **注意：素短语是算符优先文法中的概念，因此可以说素短语是算符优先文法特有的。**
* 判断方式1：根据语法树判断：
* 素短语递归定义，满足三个条件：
    ① 素短语是短语。
    ② 素短语中必须包含至少一个终结符。
    ③ 素短语中不能包含其它素短语。
* 判断方式2：根据优先关系判断：被优先关系符号所包裹（看例题吧讲不清定义又太复杂）
  
#### 例 文法

E -> T | E + T
T -> F | T *F
F -> P | P ↑ F
P -> i | ( E )
对于句型：i_1*(i_2 + i_3)

#### 解1

语法树如下：

<img src="https://telegraph-image-5ms.pages.dev/file/826d6592cf2f2c67ba461.png" alt="image-20220117083528884" style="display: block; margin-left: auto; margin-right: auto; zoom:72%;">

* 短语：i_1,i_2,i_3,i_2+i_3,(i_2+i_3),i_1*(i_2+i_3)
* 素短语：i_1,i_2,i_3
* 最左素短语：i_1

* **这玩意复杂度堪称炸裂级别的，所以十分不建议使用方法一去解。**

#### 解2

直接扣图，看图~

<img src="https://telegraph-image-5ms.pages.dev/file/ea6fea902ffa77be2d92a.png" alt="image-20220117083528884" style="display: block; margin-left: auto; margin-right: auto; zoom:72%;">
<center>图片来源于西安交通大学软件工程专业编译原理 吴晓军 2024春</center>
&nbsp;

**哈哈真简单（所以我为什么要费那么大劲去构造语法树:cry::cry::cry:）**

### 8.:ram:优先函数

#### 定义

* 我们把每个终结符θ与两个自然数f(θ)和g(θ)相对应，使得：
* 若θ_1 < θ_2，则f(θ_1) < g(θ_2)
* 若θ_1 = θ_2，则f(θ_1) = g(θ_2)
* 若θ_1 > θ_2，则f(θ_1) > g(θ_2)
* 函数f称为入栈优先函数，g称为比较优先函数。

#### 使用优先函数的优缺点

* 优：便于比较运算；节省存储空间。
* 缺：对不存在优先关系的两个终结符，由于与自然数相对应，变成可比较。

#### 优先函数的性质

* 正确性：优先函数掩盖了矩阵中出错元素对，若f(id) < g(id)，暗示id < id，但id之间无优先关系，因此失去发现错误能力，但并未严重到妨碍在可解地方使用优先函数。
* 存在性：并非总能把表映射到优先函数，例如下面这个：

|      | a    | b    |
| ---- | ---- | ---- |
| a    | =    | >    |
| b    | =    | =    |

* 唯一性：如果存在一个优先函数，则有无数多对，原因在于：加任一常数，不等式仍成立。

#### 构造优先函数的方式

* 对每个a（包括#）属于V_T，对应两个符号f_a，g_a.
* 把符号尽可能划分为许多组：
  * 若a = b，则f_a和g_b就在一组；
  * 若a = b，c = b，则f_a和f_c。同组；
* 建立一个有向图，其结点是上一步中找出的组。
  * 对于任何a和b，若 a > b，画 f_a -> g_b弧，意味着f(a) > g(b)；
  * 若a < b，画 g_b -> f_a弧，意味着f(a) < g(b)。
* 如果上一步结果构成环，则f，g不存在；
* 否则 f(a) = 从f组开始的路径和;
* g (b)= 从sb组开始的路径和。

具体例子不再给出，应该不考，不是重点。
_______________________________

## LR分析法

### 1.:blowfish:LR分析法概述

#### LR分析程序框架

<img src="https://telegraph-image-5ms.pages.dev/file/71100b0d2b1ea2b1cda0a.png" alt="image-20220117083528884" style="display: block; margin-left: auto; margin-right: auto; zoom:72%;">
<center>图片来源于西安交通大学软件工程专业编译原理 吴晓军 2024春</center>
&nbsp;

**核心是总控程序和分析表~**

#### LR分析程序概念

* LR分析法是一种“移进—归约”的自底向上语法分析方法，其本质是**规范归约**，具有以下特点：
* (1) 应用面广：能够用LR分析程序识别绝大多数的程序设计语言的语法结构；
* (2) 实现效率高：虽构造方法复杂，但是实现（执行）效率高。
* (3) 查错准确：LR分析器能够及时发现语法错误并准确指出错误位置。
* LR(k)分析方法中L是指自左(Left)向右扫描输入单词串，R指分析过程是最右(Right)推导的逆过程(规范归约)，k是指在决定当前分析动作时需向前察看的输入符号个数。
* 包括LR(0)、SLR(1)、LR(K)等多种，**考试是随机三选一！**

#### LR分析实质：分析栈+DFA

<img src="https://telegraph-image-5ms.pages.dev/file/4b72f685ffed9c67b09cf.png" alt="image-20220117083528884" style="display: block; margin-left: auto; margin-right: auto; zoom:72%;">
<center>图片来源于西安交通大学软件工程专业编译原理 吴晓军 2024春</center>
&nbsp;

#### LR分析核心：分析表

* 分析表由ACTION表和GOTO表两部分组成。
* ACTION(s, a):表示当状态s面临输入a时的动作；
* GOTO(s，x)：表示面对文法符号x的下一状态。
* ACTION(s, a)的动作种类：
  * 移进s：(shift)
  * 规约r：(reduction)
  * 结束acc
  * 报错(空格)

例子，下面的文法的构造表如下：
**文法必须有编号**
(1) E -> E + T
(2) E -> T
(3) T -> T * F
(4) T -> F
(5) F -> ( E )
(6) F -> i

|      | i    | +    | *    | (    | )    | #    | E    | T    | F    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | s5   |      |      | s4   |      |      | 1    | 2    | 3    |
| 1    |      | s6   |      |      |      | acc  |      |      |      |
| 2    |      | r2   | s7   |      | r2   | r2   |      |      |      |
| 3    |      | r4   | r4   |      | r4   | r4   |      |      |      |
| 4    | s5   |      |      | s4   |      |      | 8    | 2    | 3    |
| 5    |      | r6   | r6   |      | r6   | r6   |      |      |      |
| 6    | s5   |      |      | s4   |      |      |      | 9    | 3    |
| 7    | s5   |      |      | s4   |      |      |      |      | 10   |
| 8    |      | s6   |      |      | s11  |      |      |      |      |
| 9    |      | r1   | s7   |      | r1   | r1   |      |      |      |
| 10   |      | r3   | r3   |      | r3   | r3   |      |      |      |
| 11   |      | r5   | r5   |      | r5   | r5   |      |      |      |

#### LR文法

* LR分析法是针对LR文法的。
* 对于一个文法，如果能构造出一个分析表，使得每个入口都是唯一确定的，那他就是LR文法。
* LR(k)文法的k是指在决定当前分析动作时需向前察看的输入符号个数。
* LR文法绝不会有二义性，也就是说，绝不会发生**移进与规约冲突**和**规约与规约冲突**。

### 2.:maple_leaf:LR分析过程

<img src="https://telegraph-image-5ms.pages.dev/file/4b00b8424f3dcd241da73.png" alt="image-20220117083528884" style="display: block; margin-left: auto; margin-right: auto; zoom:72%;">
<center>图片来源于西安交通大学软件工程专业编译原理 吴晓军 2024春</center>
&nbsp;

#### 例：利用上述分析表，假定输入串为 i*i+i，描述LR分析器的工作过程

这里不再给出完整过程，不是重点。

|      | 状态             | 符号             | 输入串           |
| ---- | ---------------- | ---------------- | ----------------|
| 0    | 0                | #                | i*i+i#          |
| 1    | 05               | #i               | *i+i#           |
| 2    | 03               | #F               | *i+i#           |
| 3    | ...              | ...              | ...             |

* 第0步到第1步：表中是s5，则读入5和i；
* 第1步到第2步：
  * 表中是r6，根据第6个产生式化简，符号变成#F，状态变成06
  * GOTO表对应了3，状态变成03

### 3.:shell:LR(0)

#### LR(0)分析表的构造步骤

标准步骤：（**了解即可**）

1. 确定G的LR(0)项目
2. 以LR(0)项目为状态，构造一个能识别文法G的所有**活前缀**的NFA
3. 利用子集法将NFA确定化，成为以项目集合为状态的DFA
4. 根据上述DFA可直接构造出LR(0)分析表

简化步骤：(**也是考试的步骤**)

1. LR(0)项目集规范族的构造
2. LR(0)分析表的构造

#### LR(0)项目

* LR(0)项目简称为项目
* 定义：文法G的每一个产生式的右部添加一个圆点，称为G的一个LR(0)项目
* 项目的意义：指明在分析过程的某时刻我们看到产生式多大一部分
* 项目在计算机中的表示：(m, n)
* m代表产生式编号
* n指出圆点的位置
* 例子：对于A -> XY有三个项目，分别是A -> $·$XY ， A -> X$·$Y ， A -> XY$·$
* 但是对于A -> $\epsilon$空字，只有一个项目A -> $·$

#### 前缀、活前缀

* 前缀指该字的任意首部
* 如：abc的前缀包括$\varepsilon,a,ab,abc$
* **活前缀**：规范句型的一个前缀，该前缀不含句柄之后的任何符号。
* **活前缀包含的句柄并不完整**，完整了就会直接规约了

#### 利用CLOSURE方法构造LR(0)项目集规范族

* 拓广文法
* $CLOSURE(I)$算法（其中$I$为$G$的任一项目集）
  * I的任何项目都属于$CLOSURE(I)$
  * 若$A\to \alpha \cdot B \beta$属于$CLOSURE(I)$，那么，对任何关于B的产生式$B\to \gamma$，项目$B\to \cdot \gamma$也属于$CLOSURE(I)$
  * 重复执行上述两步骤直至$CLOSURE(I)$不再增大为止
* 构造项目集规范族的方法
  * 令NFA的初态为$I$，求其$CLOSURE(I)$，得到初态项目集。即：求$CLOSURE(\{S'\to \cdot S\})$
  * 对所得项目集$I$和文法$G$的每个文法符号$X$(包括$V_T和V_N$)计算$GO(I, X)=CLOSURE(J)$，得到新的项目集，其中：$J=\{任何形如A\to \alpha X\cdot \beta的项目|A\to \alpha \cdot X \beta属于I\}$
  * 重复步骤二，直至没有新的项目集出现

#### LR(0)分析表的构造

* 若项目$A\to \alpha \cdot a\beta$属于$I_k$且$GO(I_k,a)=I_j$，$a$为终结符，则置$ACTION[k, a]$为“把$(j,a)移进栈$”，简记为“$sj$”
* 若项目$A\to \alpha \cdot$属于$I_k$，那么，对任何输入符号$a$（或者终结符#）置$ACTION[k,a]$为"用产生式$A\to \alpha$进行归约"，简记为"$rj$"：其中，假定$A\to \alpha$为文法$G’$的第$j$个产生式
* 若项目$S'\to S\cdot$属于$I_k$，则置$ACTION[k.\#]$为”接受“，简记为"$acc$"
* 若$GO(I_k,A)=I_j,A$为非终结符，则置$GOTO[k,A]=j$
* 分析表中凡不能使用规则1至4填入信息的空白格均置上“出错标志”

#### 不扯淡了直接上例子反正定义也看不懂:sweat_smile::sweat_smile:

对于文法G：

S’ -> E
E -> a A | b B
A -> c A | d
B -> c B | d
利用CLOSURE方法构造LR(0)项目集规范族，并且构造LR(0)分析表

**1.为文法编号**
(0)S’ -> E
(1)E -> a A
(2)E -> b B
(3)A -> c A
(4)A -> d
(5)B -> c B
(6)B -> d

**2.利用CLOSURE方法构造LR(0)项目集规范族**：

先得到$ I_0$ ={ $S’ -> · E , E -> · a A , E -> · b B $ }

根据$ I_0$可以得到：
$ I_1$ = GO( $ I_0$ , E ) = { $S’ -> E ·$ }
$ I_2$ = GO( $ I_0$ , a ) = { $E -> a · A , A -> · c A , A -> · d $ }
$ I_3$ = GO( $ I_0$ , b ) = { $E -> b · B , B -> · c B , B -> · d $ }

$ I_1$无法进行下一步了，跳~
同理根据$ I_2$可以得到：
$ I_4$ = GO( $ I_2$ , A ) = { $E -> a A ·$ }
$ I_5$ = GO( $ I_2$ , c ) = { $A -> c · A , A -> · c A , A -> · d $ }
$ I_6$ = GO( $ I_2$ , d ) = { $A -> d · $ }

同理根据$ I_3$可以得到：
$ I_7$ = GO( $ I_3$ , B ) = { $E -> b B ·$ }
$ I_8$ = GO( $ I_3$ , c ) = { $B -> c · B , B -> · c B , B -> · d $ }
$ I_9$ = GO( $ I_3$ , d ) = { $B -> d · $ }

$ I_4$无法进行下一步了，跳~
同理根据$ I_5$可以得到：
$ I_{10}$ = GO( $ I_5$ , A ) = { $A -> c A ·$ }，没有重复
GO( $ I_5$ , c ) = { $A -> c · A , A -> · c A , A -> · d $ } = $ I_{5}$
GO( $ I_5$ , d ) = { $A -> d · $ } = $ I_{6}$

$ I_6$无法进行下一步了，跳~
$ I_7$无法进行下一步了，跳~
$ I_8$ 分析和$ I_5$类似
$ I_{11}$ = GO( $ I_8$ , B ) = { $B -> c B ·$ }，没有重复
GO( $ I_8$ , c ) = { $B -> c · B , B -> · c B , B -> · d $ } = $ I_{8}$
GO( $ I_8$ , d ) = { $B -> d · $ } = $ I_{9}$

$ I_9$无法进行下一步了，跳~
$ I_{10}$无法进行下一步了，跳~
$ I_{11}$无法进行下一步了，跳~
分析结束~~

**3.利用LR(0)项目集规范族构造LR(0)分析表**：

掏出一张空表：
|      | a    | b    | c    | d    | #    | E    | A    | B    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    |      |      |      |      |      |      |      |      |
| 1    |      |      |      |      |      |      |      |      |
| 2    |      |      |      |      |      |      |      |      |
| 3    |      |      |      |      |      |      |      |      |
| 4    |      |      |      |      |      |      |      |      |
| 5    |      |      |      |      |      |      |      |      |
| 6    |      |      |      |      |      |      |      |      |
| 7    |      |      |      |      |      |      |      |      |
| 8    |      |      |      |      |      |      |      |      |
| 9    |      |      |      |      |      |      |      |      |
| 10   |      |      |      |      |      |      |      |      |
| 11   |      |      |      |      |      |      |      |      |

1. 先找acc避免遗忘，$S’ -> E ·$ 在$I_1$:

|      | a    | b    | c    | d    | #    | E    | A    | B    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    |      |      |      |      |      |      |      |      |
| 1    |      |      |      |      | acc  |      |      |      |
| 2    |      |      |      |      |      |      |      |      |

2. 按顺序看$I_0$：
   * 第一个项目$S’ -> · E$，点后面是非终结符E，因为$ I_1$ = GO( $ I_0$ , E )，所以输入E前往状态$I_1$，所以GOTO表的第0行第E列写1；
   * 第二个项目$ E -> · a A$，点后面是a，因为$ I_2$ = GO( $ I_0$ , a )，所以输入a以后前往$I_2$，则ACTION表第0行第a列写s2。
   * 第三个项目$ E -> · b B $，点后面是b，因为$ I_3$ = GO( $ I_0$ , b )，所以输入b后前往$I_3$，则ACTION表第0行第b列写s3。

|      | a    | b    | c    | d    | #    | E    | A    | B    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | s2   | s3   |      |      |      | 1    |      |      |
| 1    |      |      |      |      | acc  |      |      |      |
| 2    |      |      |      |      |      |      |      |      |
| 3    |      |      |      |      |      |      |      |      |

3. 同理往后看$I_1$：
   * 哈哈这一行只有一个项目~填过了，过！
4. 同理往后看$I_2$：
   * GOTO表A的位置填4
   * ACTION表c的位置填s5
   * ACTION表d的位置填s6
5. 同理往后看$I_3$：
   * GOTO表B的位置填7
   * ACTION表c的位置填s8
   * ACTION表d的位置填s9

|      | a    | b    | c    | d    | #    | E    | A    | B    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | s2   | s3   |      |      |      | 1    |      |      |
| 1    |      |      |      |      | acc  |      |      |      |
| 2    |      |      | s5   | s6   |      |      | 4    |      |
| 3    |      |      | s8   | s9   |      |      |      | 7    |

6. 同理往后看$I_4$：
   * 对项目$E -> a A ·$，A可以规约，根据(1)E -> a A ，我们在ACTION表上都填上r1。

|      | a    | b    | c    | d    | #    | E    | A    | B    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | s2   | s3   |      |      |      | 1    |      |      |
| 1    |      |      |      |      | acc  |      |      |      |
| 2    |      |      | s5   | s6   |      |      | 4    |      |
| 3    |      |      | s8   | s9   |      |      |      | 7    |
| 4    | r1   | r1   | r1   | r1   | r1   |      |      |      |

7. 同理往后看$I_5$：
   * GOTO表A的位置填10
   * ACTION表c的位置填s5
   * ACTION表d的位置填s6
8. 同理往后看$I_6$：
   * (4)A -> d ，我们在ACTION表上都填上r4。
9. 同理往后看$I_7$：
   * (2)E -> b B，我们在ACTION表上都填上r2。
10. 同理往后看$I_8$：

* GOTO表B的位置填11
* ACTION表c的位置填s8
* ACTION表d的位置填s9

11. 同理往后看$I_9$：

* (6)B -> d ，我们在ACTION表上都填上r6。

12. 同理往后看$I_{10}$：

* (3)A -> c A ，我们在ACTION表上都填上r3。

13. 同理往后看$I_{11}$：

* (5)B -> c B，我们在ACTION表上都填上r5。

|      | a    | b    | c    | d    | #    | E    | A    | B    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | s2   | s3   |      |      |      | 1    |      |      |
| 1    |      |      |      |      | acc  |      |      |      |
| 2    |      |      | s5   | s6   |      |      | 4    |      |
| 3    |      |      | s8   | s9   |      |      |      | 7    |
| 4    | r1   | r1   | r1   | r1   | r1   |      |      |      |
| 5    |      |      | s5   | s6   |      |      | 10   |      |
| 6    | r4   | r4   | r4   | r4   | r4   |      |      |      |
| 7    | r2   | r2   | r2   | r2   | r2   |      |      |      |
| 8    |      |      | s8   | s9   |      |      |      | 11   |
| 9    | r6   | r6   | r6   | r6   | r6   |      |      |      |
| 10   | r3   | r3   | r3   | r3   | r3   |      |      |      |
| 11   | r5   | r5   | r5   | r5   | r5   |      |      |      |

**LR（0）最显著的特征**:ACTION表规约的行是相同的。

### 4.:musical_note:SLR

#### 概念

* SLR的S是simple的意思~
* 与LR(0)相比的优缺点：
* 优点：可以处理更多种类的文法，毕竟LR(0)能处理的文法实在有限。
* 缺点：稍微难构造一点，可以处理的文法更多了但又没那么多~
  
#### 构造方法

* **跟LR(0)非常类似，只有一点不同，在根据项目集规范族构造分析表的时候，对于规约的操作，要向前展望，看一下FOLLOW集。**
* **必须掌握FIRST集和FOLLOW集的构建！**
* 上栗子！！别慌，先回忆下FOLLOW集求法，待会得用。

#### FOLLOW集

**求FOLLOW集合的意思就是求非终结符右边所有终结符的集合。**

E -> TE’
E’ -> +TE’ | ε
T -> FT’
T’ -> *FT’ | ε
F -> (E) | id

**求FOLLOW集的绝家秘法！！！**

1. 将#放到FOLLOW(S)中，其中S是文法的开始符号。
2. 从上向下扫描每一个文法式子，对于右边的每一个非终结符：
   * 把所有跟在非终结符后面的终结符加入对应的FOLLOW集合(F -> (E)，把)加入E的FOLLOW集合)；
   * 对于所有跟在非终结符后面的非终结符号(T -> FT’，**直接**把T’的FIRST集合中的元素(除了ε)加入F的FOLLOW集合)
   * 这一步只需要执行一次，并且完全不用考虑式子的左半部分。
   * 我们关注式子的右半部分，关注每一个非终结符。
3. 从上向下扫描每一个文法式子，对于右边的每一个非终结符:
   * 对于末尾的非终结符(E -> TE’的E’)，直接把FOLLOW(E)加入FOLLOW(E’);
   * 对于非末尾的非终结符(E -> TE’的T)，考察FIRST(E’)是否包含ε，如果包含那么也把FOLLOW(E)加入FOLLOW(T)。
   * **这一步需要执行多次，最好进行检验。**
   * 我们需要关注右边的每一个非终结符。

#### 上栗子

**前面完全和LR(0)一致，直到开始在表中写r开始变得不同~**

|      | a    | b    | c    | d    | #    | E    | A    | B    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | s2   | s3   |      |      |      | 1    |      |      |
| 1    |      |      |      |      | acc  |      |      |      |
| 2    |      |      | s5   | s6   |      |      | 4    |      |
| 3    |      |      | s8   | s9   |      |      |      | 7    |

LR(0)当初是这样写的：

6. 同理往后看$I_4$：
   * 对项目$E -> a A ·
$，A可以规约，根据(1)E -> a A ，我们在ACTION表上都填上r1。

所以：

|      | a    | b    | c    | d    | #    | E    | A    | B    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | s2   | s3   |      |      |      | 1    |      |      |
| 1    |      |      |      |      | acc  |      |      |      |
| 2    |      |      | s5   | s6   |      |      | 4    |      |
| 3    |      |      | s8   | s9   |      |      |      | 7    |
| 4    | r1   | r1   | r1   | r1   | r1   |      |      |      |

SLR的话我们这样改：

6. 同理往后看$I_4$：
   * 对项目$E -> a A ·
$，A可以规约，根据(1)E -> a A ，我们查看FOLLOW(E)集合，发现只有一个#，那么我们就只在#列填r1

|      | a    | b    | c    | d    | #    | E    | A    | B    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | s2   | s3   |      |      |      | 1    |      |      |
| 1    |      |      |      |      | acc  |      |      |      |
| 2    |      |      | s5   | s6   |      |      | 4    |      |
| 3    |      |      | s8   | s9   |      |      |      | 7    |
| 4    |      |      |      |      | r1   |      |      |      |

### 5.:panda_face:规范规约：LR(k)

#### 概念

* 构造问题：有些无二义文法会产生“移进/归约”冲突或“归约/归约”冲突。
* 产生原因：SLR分析法未包含足够多的“展望”信息。
* 解决办法：让每个状态含有更多的“展望”信息。
* 方法：重新定义项目，使得每个项目都附带有k个终结符，即每个项目的形式为：[A->a$·$β，$a_1 a_2 \cdots a_k$]。
* 定义:如上形式的项目称为一个LR(k)项目。
* 说明：
  * 向前搜索符串仅对归约项目[A->a·，$a_1 a_2 \cdots a_k$]有意义；
  * 归约项目[A->a·，$a_1 a_2 \cdots a_k$]意味着：当它所属的状态呈现在栈顶且后续的k个输入符号为$a_1 a_2 \cdots a_k$时，才可以把栈顶上的a归约为A；
* 我们只研究k≤1的情形，因为当k = 1的时候已经很很很复杂了，并且已经可以满足绝绝绝大部分需要了~

#### 确定LR(1)项目

确定LR(1)项目的方法：

* ① 对S和S’，只向前搜索#；
* ② 其他产生式，对每一个$V_t$(含#)均向前搜索。

栗子！
(0) S' -> S
(1) S -> aB
(2) B -> BB
(3) B -> b

由(0)和(1)：
S' -> [·S,#]
S' -> [S·,#]
S -> [·BB,#]
S -> [B·B,#]
S -> [BB·,#]

由(2)和(3)：
B -> [·aB,a]
B -> [·aB,b]
B -> [·aB,#]
B -> [a·B,a]
B -> [a·B,b]
B -> [a·B,#]
B -> [aB·,a]
B -> [aB·,b]
B -> [aB·,#]
B -> [·b,a]
B -> [·b,b]
B -> [·b,#]
B -> [b·,a]
B -> [b·,b]
B -> [b·,#]

**是不是写起来很累，对啦，就没打算让你写，这就是让你康康就行的！**

#### LR(1)分析表的构造步骤

跟LR(0)分析表的构造一样~

标准步骤:(**同样了解即可**)

* 确定LR(1)项目
* 根据与LR(1)项目构造NFA
* 利用函数CLOSURE和GO求DFA
* 根据DFA构造规范LR分析表

简化步骤：(**也是考试的步骤**)

* LR(1)项目集规范族的构造
* LR(1)分析表的构造

#### LR(1)分析的项目集闭包

假定I是文法G'的任一项目集,定义和构造1的闭包CLOSURE(I)如下：

* I的任何项目都属于CLOSURE(I)。
* 若项目[A -> α·Bβ，a]属于CLOSURE(I),B -> $\xi$是一个产生式,那么,对于FIRST(βa)中的每个终结符b，如果[B -> $\xi$，b]原来不在CLOSURE(I)中，则把它加进去。
* 重复执行步骤2,直至CLOSURE(I)不再增大为止。

#### 项目集的转换函数GO

令I是一个项目集，X是一个文法符号，函数GO(I，X)定义为：
$$GO(I, X)=CLOSURE(J)$$
其中
$$J = {任何形如[A→αX·β,α]的项目| [ A→α٠Xβ, α]∈I}$$

#### 直接上例子（重中之重！！）

构造如下拓广文法的规范LR分析表

S -> BB
B -> aB
B -> b

**1.为文法编号**
(O) S' -> S
(1) S -> BB
(2) B -> aB
(3) B -> b

**2.利用CLOSURE方法构造LR(1)项目集规范族**：

* 1. 先写$ I_0$ = { [S’ -> · S , #] }
  2. 发现 · 后面有非终结符号，写出S的有关项，则$ I_0$ = { [S’ -> · S , #] , [S -> · B B , #]}，因为S和S’的项目的搜索符号只有#，自然不必多说。
  3. 发现 · 后面有非终结符号，写出B的有关项，则$ I_0$ = { [S’ -> · S , #] , [S -> · B B , #] , [B -> · a B , ?] , [B -> · b , ?] }
  4. 那么?处到底填什么呢，我们观察[S -> · B B , #]这个项目，当 · 向后移位到第一个B后面时，搜索的就是第二个B了，那么我们填入a/b，则$ I_0$ = { [S’ -> · S , #] , [S -> · B B , #] , [B -> · a B , a/b] , [B -> · b , a/b] }
  5. 至此$ I_0$总算是写完了。
* 根据$ I_0$可以得到：
  1. $ I_1$ = GO( $ I_0$ , S ) = { [S’ -> S ·  , #] }
* 根据$ I_0$可以得到：
  1. $ I_2$ = GO( $ I_0$ , B ) = { [S -> B · B , #] }
  2. 发现 · 后面有非终结符号，写出B的有关项，则$ I_2$ = { [S -> B · B , #] , [B -> · a B , ?] , [B -> · b , ?] }
  3. 那么?处到底填什么呢，我们观察[S -> B · B , #]这个项目，当 · 向后移位到第二个B后面时，搜索的就是#了，那么我们填入#，则$ I_2$ = { [S -> B · B , #]  , [B -> · a B , #] , [B -> · b , #] }
* 根据$ I_0$可以得到：
  1. $ I_3$ = GO( $ I_0$ , a ) = { [B -> a · B , a/b] }
  2. 填入B的有关项，$ I_3$ = { [B -> a · B , a/b] , [B -> · a B , ?] , [B -> · b , ?] }
  3. 我们观察[B -> a · B , a/b]这个项目，当 · 向后移位到B后面时，搜索的是a/b了，所以$ I_3$ = { [B -> a · B , a/b] , [B -> · a B , a/b] , [B -> · b , a/b] }
* 根据$ I_0$可以得到：
  1. $ I_4$ = GO( $ I_0$ , b ) = { [B -> b · , a/b] }
* $ I_1$无法进行下一步了，跳~
* 根据$ I_2$可以得到：
  1. $ I_5$ = GO( $ I_2$ , B ) = { [S -> B B · , #] }
* 根据$ I_2$可以得到：
  1. $ I_6$ = GO( $ I_2$ , a ) = { [B -> a · B , #] }
  2. 填入B的有关项，$ I_6$ = { [B -> a · B , #] , [B -> · a B , ?] , [B -> · b , ?] }
  3. ? 填入#，$ I_6$ = { [B -> a · B , #] , [B -> · a B , #] , [B -> · b , #] }
* 根据$ I_2$可以得到：
  1. $ I_7$ = GO( $ I_2$ , b ) = { [B -> b · , #] }
* 根据$ I_3$可以得到：$ I_8$ = GO( $ I_3$ , B ) = { [B -> a B · , a/b] }
* 根据$ I_3$可以得到：GO( $ I_3$ , a ) = $ I_3$
* 根据$ I_3$可以得到：GO( $ I_3$ , b ) = $ I_4$
* $I_4$无法进行下一步了，跳~
* $I_5$无法进行下一步了，跳~
* 根据$ I_6$可以得到：$ I_9$ = GO( $ I_6$ , B ) = { [B -> a B · , #] }
* 根据$ I_6$可以得到：GO( $ I_6$ , a ) = $ I_6$
* 根据$ I_6$可以得到：GO( $ I_6$ , b ) = $ I_7$
* $I_7$无法进行下一步了，跳~
* $I_8$无法进行下一步了，跳~
* $I_9$无法进行下一步了，跳~
* **终于结束辣~~**

**3.利用LR(1)项目集规范族构造LR(1)分析表**：

掏出一张空表：

|      | a    | b    | #    | S    | B    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 0    |      |      |      |      |      |
| 1    |      |      |      |      |      |
| 2    |      |      |      |      |      |
| 3    |      |      |      |      |      |
| 4    |      |      |      |      |      |
| 5    |      |      |      |      |      |
| 6    |      |      |      |      |      |
| 7    |      |      |      |      |      |
| 8    |      |      |      |      |      |
| 9    |      |      |      |      |      |

1. 先找acc避免遗忘，[S’ -> S ·  , #] 在$I_1$:

|      | a    | b    | #    | S    | B    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 0    |      |      |      |      |      |
| 1    |      |      | acc  |      |      |

2. 按顺序看$I_0$：
   * 第一个项目[S’ -> · S , #]，点后面是非终结符S，因为$ I_1$ = GO( $ I_0$ , S )，所以输入E前往状态$I_1$，所以GOTO表的第0行第S列写1；
   * 第二个项目[S -> · B B , #]，点后面是非终结符B，因为$ I_2$ = GO( $ I_0$ , S )，所以输入E前往状态$I_2$，所以GOTO表的第0行第B列写2；
   * 第三个项目[B -> · a B , a/b]，点后面是a，因为$ I_3$ = GO( $ I_0$ , a )，所以输入a以后前往$I_3$，则ACTION表第0行第a列写s3。
   * 第四个项目[B -> · b , a/b]，点后面是b，因为$ I_4$ = GO( $ I_0$ , b )，所以输入b后前往$I_4$，则ACTION表第0行第b列写s4。

|      | a    | b    | #    | S    | B    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | s3   | s4   |      | 1    | 2    |
| 1    |      |      | acc  |      |      |

3. 同理往后看$I_1$：
   * 哈哈这一行只有一个项目~填过了，过！
4. 同理往后看$I_2$：
   * GOTO表B的位置填5
   * ACTION表a的位置填s6
   * ACTION表b的位置填s7
5. 同理往后看$I_3$：
   * GOTO表B的位置填8
   * ACTION表c的位置填s3
   * ACTION表d的位置填s4
6. 同理往后看$I_4$：
   * 对项目[B -> b · , a/b]可以规约，根据(3)B -> b ，我们在ACTION表的a/b填上r3。
7. 同理往后看$I_5$：
   * 对项目[S -> B B · , #]可以规约，根据(1) S -> BB ，我们在ACTION表的#填上r1。
8. 同理往后看$I_6$：
   * GOTO表B的位置填9
   * ACTION表c的位置填s6
   * ACTION表d的位置填s7
9. 同理往后看$I_7$：
   * 对项目[B -> b · , #]可以规约，根据(3)B -> b ，我们在ACTION表的#填上r3。
10. 同理往后看$I_8$：
   * 对项目[B -> a B · , a/b]可以规约，根据(2) B -> aB ，我们在ACTION表的a/b填上r2。
11. 同理往后看$I_9$：
   * 对项目[B -> a B · , #]可以规约，根据(2) B -> aB ，我们在ACTION表的#填上r2。

|      | a    | b    | #    | S    | B    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | s3   | s4   |      | 1    | 2    |
| 1    |      |      | acc  |      |      |
| 2    | s6   | s7   |      |      | 5    |
| 3    | s3   | s4   |      |      | 8    |
| 4    | r3   | r3   |      |      |      |
| 5    |      |      | r1   |      |      |
| 6    | s6   | s7   |      |      | 9    |
| 7    |      |      | r3   |      |      |
| 8    | r2   | r2   |      |      |      |
| 9    |      |      | r2   |      |      |

**终于，结束辣哈哈哈！！！**

### 6.:cat:LALR

#### 概念

* 问题：对于一般的语言，规范LR分析表要用几千个状态，无法实际应用。
* 分析：由例6可以看到，有些状态集除了搜索符不同外是两两相同的。
* 解决办法：合并同心集,构造LALR分析表。

> 我们称两个LR(1)项目集具有相同的心，如果除去搜索符之后，这两个集合是相同的。

> 将所有同心的LR(1)项目集合并后，得到一个心就是一个LR(O)项目集。

> 合并项目集时不用修改转换函数，即GO(1,X)；但是,动作ACTION应进行修改,使得能够反映各被合并的集合的既定动作。

> 合并同心集不会产生新的移进-归约冲突，但有可能产生新的“归约-归约”冲突。

> 对于同一个文法，LALR分析表和SLR分析表永远具有相同数目的状态，但却能处理一些SLR所不能对付的事情。

#### 构造方法

- 构造文法G的LR(1)项目集族$C=\{I_0,I_1,\cdots,I_n\}$
- 把所有的同心集合并在一起，记$C'=\{J_0,J_1,\cdots,J_m\}$为合并后的新族。那个含有项目$[S'\to \cdot S,\#]$的$J_k$为分析表的初态
- 从$C'$构造$ACTION$表
  - 若项目$[A\to \alpha \cdot a \beta ,b]$属于$J_k$且$GO(J_k,a)=J_i$，$a$为终结符，则置$ACTION[k,a]$为“$sj$”
  - <font color=red>若项目$[A\to \alpha \cdot ,a]$属于$J_k$，则置$ACTION[k,a]$为“用产生式$A\to \alpha$归约”，简记为"$rj$"；其中，假定$A\to \alpha$为文法$G'$的第$j$个产生式</font>
  - 若项目$[S'\to S\cdot ,\#]$属于$J_k$，则置$ACTION[k,\#]$为"接受"，简记为“$acc$”
- 构造$GOTO$表
- 分析表中凡不能用步骤3、4填入信息的空白格均填上“出错标志”

#### 好好好我知道你们都不看，上栗子！

**对于刚刚构造的LR(1)项目集规范族，进行同心集合并。**

$ I_{36}$ = { [B -> a · B , a/b/#] , [B -> · a B , a/b/#] , [B -> · b , a/b/#] }
$ I_{47}$ = GO( $ I_0$ , a/b/# ) = { [B -> b · , a/b/#] }
$ I_{89}$ = GO( $ I_3$ , a/b/# ) = { [B -> a B · , a/b/#] }

**重新写构造表（规则完全一致）。**

<img src="https://telegraph-image-5ms.pages.dev/file/30c677a7b508d7bddea38.png" alt="image-20220117083528884" style="display: block; margin-left: auto; margin-right: auto; zoom:72%;">
<center>图片来源于西安交通大学软件工程专业编译原理 吴晓军 2024春</center>
&nbsp;
_______________________________
## 五、本章总结

* 简单来说，这一章是重点中的重点，内容也相当多（看我这1000多行就知道了），相对也比较难理解，当然考的分也很多，**就单纯的大题，算符优先分析约10分，LR分析约17分，比前面几章加起来的分都多**，所以一定要好好学习~
* 写题时要注意：看小分写，一般3分对应3个；步骤写全，别偷懒。

**我，我的任务完成辣！~~啊哈哈哈哈哈！！（穿山甲的狂笑~）**

_______________________________