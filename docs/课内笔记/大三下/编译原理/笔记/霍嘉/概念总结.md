# 第二章

- **文法**是描述语言的语法结构的形式规则（即语法规则）

- 文法主要分成四类：0,1,2,3四类文法，与程序语言有关的是**上下文无关文法**

- 一个**上下文无关文法G**是一个四元式$(V_T,V_N,S,P)$，其中：

  - $V_T$：是非空有限集，它的每个元素是终结符号；

  - $V_N$：是非空有限集，它的每个元素是非终结符号；
    $$
    V_T\cap V_N=\Phi \qquad V_T\cup V_N = V
    $$

  - S：$S\in V_N$，称为开始符号

  - $P$：产生式集合（有限），每个产生式的形式是 $\{P\rightarrow\alpha|P\in V_N,\alpha\in(V_T\cup V_N)^*,S至少一次为P\}$

- **直接推出**：如：$(\alpha\ A\ \beta)\ R \ (\alpha \ \gamma\ \beta)$，表示：若$A\rightarrow \gamma\in P,\alpha、\beta\in V^*$，则$R$就是直接推出，$R$记为$\Rightarrow$。即：$\alpha\ A \ \beta \Rightarrow \alpha \ \gamma\ \beta$

- **推导**：推导的最后是由终结符组成的终结符串

  - $u_o\stackrel{+}{\Rightarrow}u_n$：表示从$u_o$出发，经一步或若干步，可以推导出$u_n$
  - $u_o\stackrel{*}{\Rightarrow}u_n$：表示从$u_o$出发，经零步或若干步，可以推导出$u_n$

- 从开始符号开始推导得到的串称为文法的**句型**，$S\stackrel{*}{\Rightarrow}\alpha,\alpha\in V^*$，则称$\alpha$为G的句型，如果要求这个串全部由终结符组成，则这个串是文法的**句子**，文法G产生的句子的全体是一个**语言**，记为$L(G)$

- 句子一定是终结符串，但是终结符串不全是句子，生成的串要与开始符号存在$\stackrel{+}{\Rightarrow}$关系才可以

- 句型是终结符和非终结符的混合串，但是他们的混合串不一定全是句型，生成的串需要与开始符号存在$\stackrel{*}{\Rightarrow}$关系才可以（==S是不是句型？==）

- 语言是由句子构成的，**$V_T^*$不代表语言(表示的意思是所有终结字符串)，$V^*$不代表句型集（代表所有字符和非终结字符的串）**

- 一个文法可以通过最左推导和最右推导得到

- 如果文法G的某一句子有两个不同的树，则G为二义的

- 语言的二义性问题与文法的二义性问题：

  - 如语言找到一个文法是无二义的，则语言是无二义的
  - 如未找到一个文法是无二义的，则也不能断定它二义，但先天二义也存在
  - 文法的二义性是不可判定的（因为文法的二义性由句子的语法树判定，不可能对无穷句子来判别）

# 第三章

- 词法分析器输出的单词符号有五种：**关键字，标识符，常数，界符，运算符**
- 单词类别可以有**一类一种**和**一符一种**
- 单词符号表示为二元式：（单词种别，单词自身的值）
- 词法分析器的设计前提是把Scanner作为一个独立的子程序（除此之外可以把Scanner作为语法分析的子程序）
- **预处理**是为了去掉语句中的空白符，回车符等
- 预处理子程序从输入缓冲区中读取字符，将处理结果放入扫描缓冲区中交由扫描器使用
- 扫描缓冲区包含**起点指示器**和**搜索指示器**，是由两个互补的扫描缓冲区组成的，每个的大小是120个字符
- 状态转换图的功能：识别符合一定要求的字符串，节点代表**状态**，状态之间使用箭弧链接，箭弧上的标记（字符）代表在射出节点状态下可能出现的输入字符或字符类
- 可以使用**超前搜索**来识别单词符号，具体表现为终态结点上的*
- 字母表是一个非空有穷集合，通常用$\Sigma$表示，其中的元素称为字母，或者符号，或者字符（一般都是称为字符）
- 字母表的两个特性：**非空性和有穷性**（字母表中的字符特性：整体性和可辨认性）
- $\Sigma$的正闭包（$\Sigma^+$），$\Sigma$的克林闭包（$\Sigma^*$，默认是这个，与正闭包的区别只在于增加了空串，即$\Sigma^*=\{\varepsilon\}\cup\Sigma^+$）
- 对于任何$x\in\Sigma^*$，x即$\Sigma$上的一个**句子**(sentence)，也叫做**符号串**
- **证明两个正规集相等可以从正规集出发，证明集合相等**
- **确定有限自动机**，DFA M是一个五元式$M=(S,\Sigma,\delta,s_0,F)$，其中
  - S是一个有限集，它的每个元素称为一个**状态**
  - $\Sigma$是一个**有穷字母表**，它的每个元素称为一个**输入字符**
  - $\delta$是一个从$S\times\Sigma$至$S$的==单值部分映射==，$\delta(s,a)=s'$意味着：当现行状态为s、输入字符为a时，将转换到下一状态$s'$。我们称$s'$为s的一个**后继状态**
  - $s_0\in S$是唯一的**初态**（不可空）
  - $F\subseteq S$是一个**终态集**（可空）
- 一个DFA可以用一个矩阵表示，该矩阵的行表示状态，列表示字符，矩阵元素表示$\delta(s,a)$的值，这个矩阵称为**状态转换矩阵**
- 约定进入的有向箭头表示初态节点，终态结点需要用双圈表示
- **非确定有限自动机**，NFA M也是一个五元式$M =\{S,\Sigma,\delta,S_0,F\}$，其中
  - S是一个**有限集**，它的每一个元素称为一个**状态**
  - $\Sigma$是一个**有穷字母表**，它的每个元素称为一个**输入字符**
  - $\delta$是一个从$S\times \Sigma^*$至S的**子集的映射**，即$\delta:S\times \Sigma^*\rightarrow2^s$
  - $S_0\subseteq S$是一个非空**初态集**（可以有多个，但至少有一个）
  - $F\subseteq S$是一个**终态集**（可空）
- DFA与NFA的区别
  - NFA可以有多个初态
  - 弧上的标记可以是$\Sigma^*$中的一个字（甚至可以是一个正规式），而不一定是单个字符
  - 同一个字可能出现在同状态射出的多条弧上

# 第四章

- 语法分析的任务：分析一个文法的句子的结构
- **自上而下推导**是从文法的开始符号出发，反复使用各种产生吃，寻找匹配的推导，即根据文法的产生式的规则，把串中出现的产生式的左部符号替换成右部，主要方法有**递归下降分析法，预测分析程序，LL分析法**
- **自下而上推导**是从输入串开始，逐步进行规约，直到文法的开始符号，规约就是根据文法的产生式规则，把串中出现的产生式的右部替换成左部符号，主要方法有：**算符优先分析法，LR分析法**
- 在进行自上而下分析时候，有两个问题非常重要：**左递归问题与回溯问题**
- 三种形式的左递归：直接左递归，间接左递归，潜在左递归
- 直接左递归改造前不能含有空字产生式，即右侧不能含有$\varepsilon$
  - 消除方法：如果$A\to A\alpha|\beta$，其中$\beta$不以A开头，则修改规则为$A\to \beta A'\quad A'\to \alpha A'|\varepsilon$
- 可以通过代入将间接和潜在左递归转换为直接左递归，一般是按照字母表的升序进行排序代入的
- 消除回溯原因的时候需要引入**首符集**，$FIRST(\alpha)=\{a|\alpha\stackrel{*}{\Rightarrow}a \cdot\cdot\cdot,a\in V_T\}，若\alpha\stackrel{*}{\Rightarrow}\varepsilon，规定\varepsilon\in FIRST(\alpha)$，$FIRST(\alpha)$不可以称为首终结符集，因为有$\varepsilon\in{FIRST(\alpha)}$
- 清楚回溯的方法是使非终结符A的所有候选式的首符集两两不相交
  - 方法为提取公因式，然后把规则改写为：$A\to \delta A'|\gamma_1|\gamma_2|\cdot\cdot\cdot|\gamma_m\quad A'\to \beta_1|\beta_2|\cdot\cdot\cdot|\beta_n$
- 在消除了左递归和回溯的情况下，构造一个自上而下的分析程序，该分析程序由一组递归过程组成，每个过程对应文法的一个非终结符，这样的一个分析程序称为**递归下降分析器**
  - 也就是在一个过程中，递归调用其他过程进行处理
  - 缺点是无成功和失败消息返回，并且出错位置不确切
- 使用一张表和一个栈实现递归下降的语法分析程序叫做**预测分析程序**
  - 需要包含四个部分：一个输入的终结符串（右端为#），一个栈（栈底为#），分析表（需要实现建好），输出
  - 栈顶符号X和当前输入符号a，由（X，a）决定程序动作，三种可能：
    1. 若$X=a=\#$，分析停止，宣告成功地完成分析
    2. 若$X=a\neq \#$ ，则X弹出栈，前移输入指针
    3. 若$X\in V_N$，则去查分析表M的元素M[X，a]，该元素或为X的产生式，或者为一个出错元素
  - 在**构造预测分析表**的过程中需要用到**首符集和后继符集**
    - $FIRST(\alpha)=\{a|\alpha\stackrel{*}{\Rightarrow}a\cdot\cdot\cdot,a\in V_T\},若\alpha\stackrel{*}{\Rightarrow}\varepsilon，规定\varepsilon\in FIRST(\alpha)$
    - $FOLLOW(A)=\{a|S\stackrel{*}{\Rightarrow}\alpha Aa\beta,a\in V_T,\alpha,\beta \in V^*\}$，即句型当中的跟在非终结符后面的终结符
- LL(1)分析法：第一个L表示从左到右扫描输入串，第二个L表示最左推导，(1)表示分析时每一步只需向前查看一个符号
  - 如果一个的分析表M不含多重定义入口，则称他是一个LL(1)文法
  - LL(1)文法的条件：对于文法的每一个非终结符A的任何两个不同的产生式，有：
    - $FIRST(\alpha)\cap FIRST(\beta) = \phi$
    - 若$\beta \stackrel{*}{\Rightarrow} \varepsilon$，则$FIRST(\alpha) \cap FOLLOW(A) = \phi$

# 第五章

- **自下而上分析**：从输入串开始，逐步进行规约，知道规约到文法的开始符号S，即“移进 - 规约”法

- **规约**：利用栈，输入符号移进栈，当栈顶形成P的候选式时，就规约为它的左部P符号

- **短语**：令G是一个文法，S是文法的开始符号，若$\alpha \beta \delta$是文法G的一个句型，如果有$S\stackrel{*}{\Rightarrow}\alpha A \delta且 A\stackrel{+}{\Rightarrow}\beta$，则称$\beta$是句型$\alpha\beta\delta$相对于非终结符A的短语 

- **直接短语**：如果有$A\to \beta$，则称$\beta$是句型$\alpha\beta\delta$相对于规则$A\to \beta$的直接短语

- **句柄**：一个句型的最左直接短语称为该句型的句柄

- **规范推导**：即最右推导

- **规范句型**：由规范推导所得到的句型称为规范句型

- **规范归约**：是关于句型$\alpha$的一个最右推导的逆过程，也称最左规约

- 所谓素短语是指这样一个短语，它至少含有一个终结符，并且除自身之外不再含任何更小的**素短语**

- 句型最左边的那个素短语叫**最左素短语**

- 在按“移进-规约”方式进行自上而下语法分析时候，可规约串是**句柄**

- 分析程序的动作：移进，规约，接受，出错

- **直观算符优先分析算法**：通过构造运算符栈和操作数栈来实现，在读入数字时候直接入栈，读入符号时候与栈顶符号进行比较，如果当前读入符号优先级高则符号入栈，如果当前符号优先级低，则处理栈顶的符号了，如果相等且两个都为#，则分析成功

- 需要注意的是终结符之间的优先关系的传递以及逆都不成立

- **算符文法**：如果一个文法的任何产生式右部都不含两个并列的非终结符，即不含有如下形式的产生式右部$\cdots QR \cdots$，则我们称该文法为算符文法

- **算符优先分析算法**：如果一个算符文法中的任何终结符对至多只满足$a\eqcirc b,a\lessdot b, a\gtrdot b$关系之一，则称该文法为算符优先文法，算符优先分析法不是一种规范归约法

- **优先函数**：

- 我们把每个终结符$\theta$与两个自然数$f(\theta)$和$g(\theta)$相对应，使得：

  - 若$\theta_1\lessdot \theta_2$，则$f(\theta_1)< g(\theta_2)$
  - 若$\theta_1\eqcirc \theta_2$，则$f(\theta_1)= g(\theta_2)$
  - 若$\theta_1\gtrdot \theta_2$，则$f(\theta_1)> g(\theta_2)$

  函数$f$称为**入栈优先函数**，$g$称为**比较优先函数**，构造的方法可以再去看一下笔记的对应地方

- LR分析程序：自左向右扫描，识别句柄，自下而上规约的语法分析程序

- LR分析表的核心是分析表，由两部分组成：**ACTION和GOTO**

- 共有四种方法：LR(0)，SLR，LR(1)，LALR

- **LR文法**：对于一个文法，如果能够构造一张分析表，使得它的每个入口均是唯一确定的，则我们把这个文法称为LR文法

- 文法G的每一个产生式的右部添加一个圆点，称为G的一个**LR(0)项目**，其意义是指明在分析过程中的某时刻我们能看到多大一部分

- **字的前缀**：指该字的任意首部

- **活前缀**：规范句型的一个前缀，该前缀不含句柄之后的任何符号，活前缀包含的经并不完整，完整了就会直接规约了

- LR(0)文法：不存在移进规约冲突与规约规约冲突的文法

- SLR其实就是SLR(1)，S是Simple，也就是简单的LR(1)算法

- 如果除去搜索符之后，这两个集合是相同的，我们称两个LR(1)项目集具有**相同的心**

# 第六章

- 语义分析的任务是对语法分析所识别出的各类语法范畴，分析其含义，并进行初步翻译
- 包括两个方面的工作：**静态语义检查和中间代码翻译**
- S属性文法和L属性文法的并集不是全体的属性文法，L属性文法是一个更大的属性文法，其中包含了S属性文法，但是L文法也不是全体的属性文法，$\{属性文法\}\supset \{L-属性文法\} \supset \{S-属性文法\}$
- **属性文法**（也称为属性翻译文法）是在上下文无关文法的基础上，为每个文法符号（终结符或非终结符）配备若干相关的值（或者称为属性），属性加工的过程就是语义处理的过程
- 属性通常分为两类
  - 综合属性：自下而上传递信息，根据子节点的属性和父节点自身的属性计算父节点的综合属性
  - 继承属性：自上而下传递信息，根据父节点和兄弟节点的属性计算子节点的继承属性
- 语义规则：为文法的每个产生式都配备的一组属性的计算规则
- 终结符只有综合属性，他们由词法分析器提供
- 非终结符既可以有综合属性也可以有继承属性，文法的开始符号的所有继承属性作为属性计算前的初始值
- 为出现在产生式右边的继承属性和出现在产生式左边的综合属性都必须提供一个计算规则，左边的继承属性和右边的综合属性由其他产生式的属性计算规则或者属性计算器的参数提供
- 语义规则所描述的工作可以包括：属性计算，静态语义检查，符号表操作，代码生成
- 仅仅使用综合属性的属性文法称为**S-属性文法**
- 基于属性文法的处理过程：输入串$\to$语法树$\to$依赖图$\to$语义规则计算次序
- 在一颗语法树中的结点的继承属性和综合属性之间的相互依赖关系可以由称作**依赖图**的一个有向图来描述，如果在一颗语法树中一个结点的属性b依赖于属性c，那么这个节点处计算b的语义规则必须在确定c的语义规则之后使用（在图中为c指向b）。
- **良定义属性文法**：如果一个文法不存在属性之间的循环依赖关系，那么该属性文法为良定义的（我们只处理良定义的属性文法）
- 属性计算方法：
  - 依赖图：建立属性之间相互关系的有向图，可能需要多遍的扫描才能完成
  - 树遍历：按照某种顺序遍历语法树，在遍历的过程中计算属性，可能需要多次遍历才能计算完所有的属性
  - 一遍扫描的属性计算方法：在语法分析的同时计算计算属性值，只需要一遍扫描即可，常用的方法有：S-属性文法和L-属性文法
- 一遍扫描的处理方法与**所采用的语法分析方法和属性的计算次序**密切相关
- **抽象语法树**：在语法树中去掉对那些对翻译不必要的信息，从而获得更有效的源程序的中间表示，这种经变换过后的语法树称为抽象语法树，在抽象语法树中，**操作符**和**关键字**都不作为叶结点出现，而是把他们作为内部节点，即这些叶结点的父结点。
- **S-属性文法**的翻译通常可以借助LR分析器来实现，在S-属性文法的基础上，LR分析器可以改造为一个翻译器，在对输入串进行语法分析的同时对属性进行计算
  - 使用翻译栈进行来存放已经分析过的子树的信息，存储两项信息：state和val
  - 用代码段来代替语义规则

- 词法分析：扫描器，语法分析：分析器，语义分析：翻译器
- **L-属性文法**：如果对于每个产生式$A\to X_1X_2\cdots X_n$，其每个语义规则中的每个属性或者是综合属性，或者是$X_j(1\le j \le n)$的一个继承属性且这个继承属性仅依赖于：
  - $X_j$的左边符号$X_1,X_2,\cdots,X_{j-1}$的属性
  - A的继承属性
- **属性文法**可以看做是语言翻译的高级规范说明，其中隐去实现细节，是用户从明确说明翻译顺序的工作中解脱出来
- **翻译模式**给出了使用语义规则进行计算的次序，在翻译模式中，和文法符号相关的属性和语义规则（也称为**语义动作**），用花括号{}括起来，插入到产生式右部的合适位置
- 在翻译模式中如果要使用自上而下的语法分析则必须需要消除文法中的左递归，这时候会**引入一些其他的继承属性**
- 自下而上计算继承属性的分析过程中实现了L-属性文法，这种方法可以实现**任何基于LL(1)文法的L-属性文法**，它还可以实现**许多（不是所有）基于LR(1)文法的L-属性文法**
- 通过引入标记非终结符可以从翻译模式中去掉嵌入在产生式中间的动作
- 通过改变基础文法来使用综合属性替代继承属性









# 题目总结

## 选择题

![image-20220429114048669](http://cdn.Hydrion-qlz.top/blog/202205242350117.png)

![image-20220429114619938](http://cdn.Hydrion-qlz.top/blog/202205242350125.png)

![image-20220429114748770](http://cdn.Hydrion-qlz.top/blog/202205242350142.png)

![image-20220429115518384](http://cdn.Hydrion-qlz.top/blog/202205242350571.png)

![image-20220429115543431](http://cdn.Hydrion-qlz.top/blog/202205242350583.png)

伪属性是在构造语法树时候用来站位的，本质还是一个综合属性

![image-20220429115555766](http://cdn.Hydrion-qlz.top/blog/202205242350587.png)



## 第一题（NFA确定化及DFA化简）

将NFA确定化为DFA，然后进行DFA的化简

![image-20220429115000266](http://cdn.Hydrion-qlz.top/blog/202205242349844.png)

通过子集算法来将NFA确定化

**确定化处理步骤**：

- 找初始节点的空字闭包（$\varepsilon\_CLOSURE(I)$），写到第一行的第一列

- 再找一步转移闭包，再找空字闭包，写第一行的后面所有各列
- 然后看该集合是不是在第一列出现了
  - 如果没出现把他写到第一列继续处理
- 直到全部处理结束

**化简步骤：**

- 先按终态和非终态结点进行分组
- 在两个组分别做一步转移（注意这里不用再找空字闭包了，因为已经是DFA了，DFA中不包含空串）
- 观察两个组的后继结点是不是前继结点的子集，如果不是则要进一步分割，如果是就不用了
- 根据后继结点是否相同进行分割
- 将分割后的结点写在左侧进行进一步的划分

## 第二题（LL(1)文法）

![image-20220321091505768](http://cdn.hydrion-qlz.top/gitee/image-20220321091505768.png)

![image-20220321091838548](http://cdn.hydrion-qlz.top/gitee/image-20220321091838548.png)

![image-20220321092205648](http://cdn.hydrion-qlz.top/gitee/image-20220321092205648.png)

![image-20220321092328741](http://cdn.hydrion-qlz.top/gitee/image-20220321092328741.png)

![image-20220321092432373](http://cdn.hydrion-qlz.top/gitee/image-20220321092432373.png)

![image-20220413173229323](http://cdn.Hydrion-qlz.top/blog/202204131732667.png)

> 首符集中可以包含空串，但是后继符集中只能包含终结符

### 构造首符集

$FIRST(\alpha)=\{a|\alpha\stackrel{*}{\Rightarrow}a\cdot\cdot\cdot,a\in V_T\},若\alpha\stackrel{*}{\Rightarrow}\varepsilon，规定\varepsilon\in FIRST(\alpha)$

- 如果是终结符，则首符集就是自己，即$FIRST(X)$是$\{X\}$
- 如果是非终结符（$X\in V_N$），
  - 情况一：右侧第一个是终结符（$X\to a\alpha$），则$\{a\}\cup FIRST(X)$
  - 情况二：右侧是空串（$X\to \varepsilon$），则$\{\varepsilon\}\cup FIRST(X)$
- 如果是非终结符，并且右侧的第一个元素是另一个非终结符（这里有个前提是，文法中已经不包括左递归了，所以这里只能是其他非终结符而不能是自己），Y中的首符集的非空串全部纳入X的首符集中
  - 形式化语言描述是，若$X\in V_N,X\to Y\cdot\cdot\cdot,Y\in V_N$，则$FIRST(Y) \setminus \{\varepsilon\} \cup FIRST(X)$
  - 如果Y的首符集包含空串$\varepsilon$，则继续看Y后面的元素，按照这三个规则继续扩充X的首符集
- 如果右侧所有字符的首符集都包含空串，则把空串也加入X的首符集中

### 构造后继符集

$FOLLOW(A)=\{a|S\stackrel{*}{\Rightarrow}\alpha Aa\beta,a\in V_T,\alpha,\beta \in V^*\}$，即句型当中的跟在非终结符后面的终结符

> #属于FOLLOW（S），一定不能忘了

应用下列规则，直到再没有什么加进任一$FOLLOW$为止

- #属于$FOLLOW(S)$
- 若存在$A\to a B \beta$，则$FIRST(\beta) \subset FOLLOW(B),\varepsilon$除外
- 若有$A\to aB,或A\to a B \beta 且 \varepsilon\in FIRST(\beta),则FOLLOW(B) \supset FOLLOW(A)$，把A的位置用$\alpha B$替换之后，原来跟在A后面的现在就跟在B的后面了

### 构造分析表

> 就是说对于一个产生式，先把其加入$[A,a]$，$a$是它的首符集的一个元素，然后如果首符集中有空串，就把其也加入$[A,b]$，b是后继符集中的元素

- 对于文法的每一个$A\to \alpha$，做下面两步
- 对于任何$a \in FIRST(\alpha)$，把$A\to \alpha$加进$M[A,a]$
- 若$\varepsilon \in FIRST(\alpha)$，则把$A\to \alpha$加进$M[A,b],b\in FOLLOW(A)$

### 判断是否是LL(1)文法

#### 方法一

LL(1)文法的条件：对于文法的每一个非终结符A的任何两个不同的产生式，有：

- $FIRST(\alpha)\cap FIRST(\beta) = \phi$
- 若$\beta \stackrel{*}{\Rightarrow} \varepsilon$，则$FIRST(\alpha) \cap FOLLOW(A) = \phi$

#### 方法二

看生成的分析表是否有多重入口，如果没有多重入口则说明是LL(1)文法

## 第三题（算符优先文法）

![image-20220402230052515](http://cdn.Hydrion-qlz.top/blog/202204022300894.png)



![image-20220402230115902](http://cdn.Hydrion-qlz.top/blog/202204022301087.png)

![image-20220402230130381](http://cdn.Hydrion-qlz.top/blog/202204022301678.png)

![image-20220402230204108](http://cdn.Hydrion-qlz.top/blog/202204022302404.png)

> 这例的LASTVT(w)错了，没有c

![image-20220402230224330](http://cdn.Hydrion-qlz.top/blog/202204022302468.png)

![image-20220402230241394](http://cdn.Hydrion-qlz.top/blog/202204022302669.png)

### FIRSTVT集合

$FIRSTVT(P)=\{a|P\stackrel{+}{\Rightarrow}a\cdots或P\stackrel{+}{\Rightarrow}Qa\cdots,a\in V_T 而 Q\in V_N\}$$

- $P\to a\cdots $或$P\to Qa\cdots$，则$a\in FIRSTVT(P)$
- 若$a\in FIRSTVT(Q)$，且有产生式$P\to Q\cdots$，则$a\in FIRSTVT(P)$  ，Q的首终结符也是P的首终结符

### LASTVT集合

$LASTVT(P)=\{a|P\stackrel{+}{\Rightarrow}\cdots a或P\stackrel{+}{\Rightarrow}\cdots aQ,a\in V_T 而 Q\in V_N\}$

- $P\to \cdots a $或$P\to \cdots aQ$，则$a\in LASTVT(P)$
- 若$a\in LASTVT(Q)$，且有产生式$P\to \cdots Q$，则$a\in LASTVT(P)$

### 构造优先关系矩阵

1. 对于形如$P\to \cdots ab \cdots$和形如$P\to \cdots aQb \cdots$，有$a\eqcirc b$
2. 对于形如$P\to \cdots aR \cdots$，而$b\in FIRSTVT(R)$，有$a\lessdot b$
3. 对于形如$P\to \cdots Rb \cdots$，而$a\in LASTVT(R)$，有$a\gtrdot b$
4. 对于S和终结符#，有$\# \lessdot FIRSTVT(S),LASTVT(S)\gtrdot \#$，且对$\#S\#$，有$\#\eqcirc \#$

### 判断是否为算符优先文法

如果优先关系矩阵中无多重入口，则该文法为算符优先文法

## 第四题（LR(1)文法）

![image-20220402230256600](http://cdn.Hydrion-qlz.top/blog/202204022302873.png)

![image-20220402230303873](http://cdn.Hydrion-qlz.top/blog/202204022303040.png)

![image-20220402230312412](http://cdn.Hydrion-qlz.top/blog/202204022303685.png)

![image-20220402230325612](http://cdn.Hydrion-qlz.top/blog/202204022303889.png)

![image-20220402230333213](http://cdn.Hydrion-qlz.top/blog/202204022303385.png)

![image-20220408101823919](http://cdn.Hydrion-qlz.top/blog/202204081018480.png)

![image-20220408102001585](http://cdn.Hydrion-qlz.top/blog/202204081020834.png)

![image-20220408102014781](http://cdn.Hydrion-qlz.top/blog/202204081020249.png)

![image-20220408102100707](http://cdn.Hydrion-qlz.top/blog/202204081021289.png)

![image-20220408102144757](http://cdn.Hydrion-qlz.top/blog/202204081021036.png)

### 文法拓广

文法拓广的时候直接加入一条额外的产生式：$S'\to S$，其余的不变即可，然后$S'$为新的开始符号，同时需要对所有的式子按顺序进行编号，这里需要把右部有多个候选式的式子拆开为多个产生式

> 拓广的原因是为了保证开始符号只有一个产生式

### 构造项目集规范族

> 这里四种方法都可能会考到，所以最好还是都看会

#### LR(0)文法

- 令NFA的初态为$I$，求其$CLOSURE(I)$，得到初态项目集。即：求$CLOSURE(\{S'\to \cdot S\})$
- 对所得项目集$I$和文法$G$的每个文法符号$X$(包括$V_T和V_N$)计算$GO(I, X)=CLOSURE(J)$，得到新的项目集，其中：$J=\{任何形如A\to \alpha X\cdot \beta的项目|A\to \alpha \cdot X \beta属于I\}$
- 重复步骤二，直至没有新的项目集出现

#### SLR文法

与LR(0)一样

#### LR(1)文法

> 规范LR就是LR(1)，二者是一个意思

重新定义项目，使得每个项目都附带有k个终结符，即每个项目的形式为：$[A\to \alpha\cdot\beta,a_1a_2\cdots a_k]$

归约项目$[A\to \alpha\cdot,a_1a_2\cdots a_k]$意味着：当它所属的状态呈现在栈顶且后续的k个输入符号位$a_1a_2\cdots a_k$时，才可以把栈顶上的$\alpha$规约为A

假定$I$是$G'$的任一项目集，定义和构造$I$的闭包$CLOSURE(I)$如下：

- I的任何项目都属于$CLOSURE(I)$

- 若项目$[A\to \alpha\cdot B\beta,a]$属于$CLOSURE(I)$，$B\to \xi$是一个产生式，那么，对于$FIRST(\beta a)$中的每个终结符$b$，如果$[B\to \cdot \xi,b]$原来不在$CLOSURE(I)$中，则把他加进去

- 重复执行步骤2，直至$CLOSURE(I)$不再增大为止

#### LALR文法

构造项目规范集的方法与LR(1)的方法一样

然后在LR(1)的方法构造的项目规范集上**合并同心集**

如果除去搜索符之后，这两个集合是相同的，我们称两个LR(1)项目集具有**相同的心**

合并项目集时不用修改转换函数，即$GO(I,X)$；动作$ACTION$应进行修改，使得能够反映各被合并的集合的既定动作

> 合并同心集不会产生新的移进-归约冲突，但有可能产生新的“归约-归约”冲突
>
> 对于同一个文法，LALR分析表和SLR分析表永远具有相同数目的状态，却能处理一些SLR所不能对付的事情

### 构造分析表

> 四种方法除了第二条之外其余的都一样，所以需要重点区分不同方法的第二条有什么区别
>
> - 具体做的时候先看`GO(Ii, x)  = Ij`，如果x是终结符，则在表中$[i,x]$填写$sj$，如果是终结符，则在表中$[i,x]$填写$j$即可
> - 然后看哪一个项目规范族中有类似于$A\to B \cdot$的形式的项目，如果有的话根据对应的规则在表中填写$rj$即可（四种方法主要是这里不一样）

#### LR(0)文法

- 若项目$A\to \alpha \cdot a\beta$属于$I_k$且$GO(I_k,a)=I_j$，$a$为终结符，则置$ACTION[k, a]$为“把$(j,a)移进栈$”，简记为“$sj$”
- 若项目$A\to \alpha \cdot$属于$I_k$，那么，对任何输入符号$a$（或者终结符#）置$ACTION[k,a]$为"用产生式$A\to \alpha$进行归约"，简记为"$rj$"：其中，假定$A\to \alpha$为文法$G’$的第$j$个产生式
- 若项目$S'\to S\cdot$属于$I_k$，则置$ACTION[k.\#]$为”接受“，简记为"$acc$"
- 若$GO(I_k,A)=I_j,A$为非终结符，则置$GOTO[k,A]=j$
- 分析表中凡不能使用规则1至4填入信息的空白格均置上“出错标志”

#### SLR文法

- 若项目$A\to \alpha\cdot a\beta$属于$I_k$且$GO(I_k,a)=I,a$为终结符，则置$ACTION{k,a}$为“把状态j和顾浩a移进栈”，简记为“$sj$”

- <font color=red>若项目$A\to \alpha \cdot$属于$I_k$，那么，对任何输入符号$a,a\in FOLLOW(A)$，则置$ACTION[k,a]$为“用产生式$A\to \alpha$进行规约”，简记为“$rj$”；其中，假定$A\to \alpha$为文法$G'$的第j个产生式</font>

  > 只在规约时才向前展望，即$\cdot$已到产生式末尾，则去判断$FOLLOW(A)$

- 若项目$S'\to S\cdot$属于$I_k$，则置$ACTION[k,\#]$为“接受”，简记为“acc”

- 若$GO(I_k,A)=I_j$，A为非终结符，则置$GOTO[k,A]=j$

- 分析表中凡不能使用规则1至4填入信息的空白格置上“出错标志”

#### LR(1)文法

- 若项目$[A\to \alpha \cdot a\beta,b]$属于$I_k$且$GO(I_k,a)=I_j$，$a$为终结符，则置$ACTION[k,a]$为“把$(j,a)$移进栈”，简记为“$sj$”
- <font color=red>若项目$[A\to \alpha\cdot,a]$属于$I_k$，则置$ACTION[k,a]$为“用产生式$A\to \alpha$归约”，简记为“$rj$”，其中，假定$A\to \alpha$为文法$G'$的第$j$个产生式 </font>
- 若项目$[S'\to S\cdot ,\#]$属于$I_k$，则置$ACTION[k.\#]$为“接受”，简记为“$acc$”
- 若$GO(I_k,A)=I_j$，A为非终结符，则置$GOTO[k,A]=j$
- 分析表中凡不能使用规则1至4填入信息的空白格均置上“出错标志”

#### LALR文法

> 在LR(1)的基础上合并了同心集，其他都一样

- 构造文法G的LR(1)项目集族$C=\{I_0,I_1,\cdots,I_n\}$
- 把所有的同心集合并在一起，记$C'=\{J_0,J_1,\cdots,J_m\}$为合并后的新族。那个含有项目$[S'\to \cdot S,\#]$的$J_k$为分析表的初态
- 从$C'$构造$ACTION$表
  - 若项目$[A\to \alpha \cdot a \beta ,b]$属于$J_k$且$GO(J_k,a)=J_i$，$a$为终结符，则置$ACTION[k,a]$为“$sj$”
  - <font color=red>若项目$[A\to \alpha \cdot ,a]$属于$J_k$，则置$ACTION[k,a]$为“用产生式$A\to \alpha$归约”，简记为"$rj$"；其中，假定$A\to \alpha$为文法$G'$的第$j$个产生式</font>
  - 若项目$[S'\to S\cdot ,\#]$属于$J_k$，则置$ACTION[k,\#]$为"接受"，简记为“$acc$”
- 构造$GOTO$表
- 分析表中凡不能用步骤3、4填入信息的空白格均填上“出错标志”

### 判断是否为LR(1)文法

如果分析表没有多重入口，则说明是一个LR(1)文法

# 第五题（数组元素引用）

![image-20220429111111529](http://cdn.Hydrion-qlz.top/blog/202205041828967.png)

![image-20220429111445256](http://cdn.Hydrion-qlz.top/blog/202205041828966.png)

![image-20220429111611548](http://cdn.Hydrion-qlz.top/blog/202205041829033.png)

![image-20220429111851605](http://cdn.Hydrion-qlz.top/blog/202205041829200.png)

![image-20220429112258179](http://cdn.Hydrion-qlz.top/blog/202205041829061.png)

![image-20220429112312975](http://cdn.Hydrion-qlz.top/blog/202205041829611.png)

第二题有几分就有几条四元式，顺序和个数都需要正确才给分

### 计算相对地址子项

计算相对地址子项也就是计算内情向量中的常数C，其计算方法如下：

对于三维数组：$C = (l_1d_2+i_2)d_3+i_3$

对于二维数组：$C = l_1d_2+i_2$

对于一维数组：$C=l_1$

### 四元式序列

> 这个如果有时间的话去看一下修改之后的语义动作，如果全都能看懂的话写这个就会很简单

在做的时候先数一下有多少四元式，看能不能找到给定的所有四元式，然后再按顺序写出来

从数组的第二维开始，**每扫过一维之后就需要进行一个`*，+`计算VARPART，也就是会产生两个四元式，当扫到`]`，需要计算数组的CONSTPART，会再产生一个四元式**

所以对于一个二维数组来说，类似于$A[i,k]$来说，其会有三个产生式，如果下标有计算的话需要再把计算的四元式也加上，例如对于$A[i+j,k*m]$来说有五个四元式

对于一个三维数组来说，例如$A[i,j,k]$，会有五个产生式（两个`*，+`，一个计算CONSPART）

另外在需要**使用数组元素值的时候需要变址取值**，四元式写法为：`(=[],T3[T2],_,T4)`，需要将取出的结果放到一个临时变量中待后续使用

然后在**对数组赋值的时候需要进行变址取值**，四元式写法为：`([]=,T4,_,T3[T2])`

> `T3[T2]`这种写法是偏移取指，即是对T3+T2位置的元素进行操作，其中T3为数组的CONSPART，T2位数组的VARPART

# 第六题（控制流语句的翻译）

![image-20220429112500076](http://cdn.Hydrion-qlz.top/blog/202205041829642.png)

![image-20220429113002401](http://cdn.Hydrion-qlz.top/blog/202205041829717.png)

![image-20220429113205391](http://cdn.Hydrion-qlz.top/blog/202205041829572.png)

![image-20220429113343709](http://cdn.Hydrion-qlz.top/blog/202205041829960.png)

![image-20220429113620775](http://cdn.Hydrion-qlz.top/blog/202205041829208.png)

![image-20220429113719446](http://cdn.Hydrion-qlz.top/blog/202205041828498.png)

首先还是一样的，前面给出的分表示四元式的个数，第二问的分表示BP和MERGE的总数，在做题时候先看能不能把所有的四元式和BP，MERGE数量找全

这个题的三问没有明显的先后顺序，在做的时候根据老师在题中画出的线进行规约，规约完成之后执行相应的语义动作，然后写出BP和merge

> - 一个关系算式（A<B）会产生两个四元式
> - while的结尾会产生一个四元式，总共有两个BP
> - if then else的then最后会产生一个四元式，总共有两个BP，一个MERGE
> - if then有一个BP，一个MERGE，不会产生额外的四元式
> - $\and,\or$会有一个BP，一个MERGE

另外，需要把这几种翻译模式都熟记

![image-20220423142820777](http://cdn.Hydrion-qlz.top/blog/202204231428585.png)

![image-20220425091045274](http://cdn.Hydrion-qlz.top/blog/202204302237302.png)

![image-20220425091112285](http://cdn.Hydrion-qlz.top/blog/202204302237523.png)



